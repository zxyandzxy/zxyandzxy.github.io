---
layout: post
title: "交换后字典序最小的字符串"
date: 2024-10-30
tags: [leetcode]
comments: true
author: zxy
---

**题目：**

给你一个仅由数字组成的字符串 `s`，在最多交换一次 **相邻** 且具有相同 **奇偶性** 的数字后，返回可以得到的字典序最小的字符串。如果两个数字都是奇数或都是偶数，则它们具有相同的奇偶性。例如，5 和 9、2 和 4 奇偶性相同，而 6 和 9 奇偶性不同。

**示例 1：**

**输入：** s = "45320"

**输出：** "43520"

**解释：**

`s[1] == '5'` 和 `s[2] == '3'` 都具有相同的奇偶性，交换它们可以得到字典序最小的字符串。

**示例 2：**

**输入：** s = "001"

**输出：** "001"

**解释：**

无需进行交换，因为 `s` 已经是字典序最小的。

**提示：**

- `2 <= s.length <= 100`
- `s` 仅由数字组成。

**思路：**

```
越是高位的数字变小，整体的数字就会变得更小。所以是贪心算法：优先交换左边的数字。
从左到右遍历，遇到同奇偶性，且左边的数字更大的就交换即可
```

**代码：**

```cpp
class Solution {
public:
    string getSmallestString(string s) {
        for (int i = 0; i < s.size() - 1; i++) {
            // i 和 i + 1
            if ((s[i] - '0') % 2 == (s[i+ 1] - '0') % 2) {
                if (s[i] > s[i + 1]) {
                    char tmp = s[i];
                    s[i] = s[i + 1];
                    s[i + 1] = tmp;
                    return s;
                }
            }
        }
        return s;
    }
};
```



