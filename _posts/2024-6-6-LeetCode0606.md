---
layout: post
title: "区分黑球和白球"
date: 2024-6-6
tags: [leetcode]
comments: true
author: zxy
---

**题目：**

桌子上有 `n` 个球，每个球的颜色不是黑色，就是白色。

给你一个长度为 `n` 、下标从 **0** 开始的二进制字符串 `s`，其中 `1` 和 `0` 分别代表黑色和白色的球。

在每一步中，你可以选择两个相邻的球并交换它们。

返回「将所有黑色球都移到右侧，所有白色球都移到左侧所需的 **最小步数**」。

**示例 1：**

```
输入：s = "101"
输出：1
解释：我们可以按以下方式将所有黑色球移到右侧：
- 交换 s[0] 和 s[1]，s = "011"。
最开始，1 没有都在右侧，需要至少 1 步将其移到右侧。
```

**示例 2：**

```
输入：s = "100"
输出：2
解释：我们可以按以下方式将所有黑色球移到右侧：
- 交换 s[0] 和 s[1]，s = "010"。
- 交换 s[1] 和 s[2]，s = "001"。
可以证明所需的最小步数为 2 。 
```

**提示：**

- `1 <= n == s.length <= 105`
- `s[i]` 不是 `'0'`，就是 `'1'`。

**思路：**

```
我们从结果开始想，比如1001101最后一定是这样的：0001111
那么从左往右遍历，每次遇到0我们就要将它移到左边它该在的位置上。
由于0和0交换是没有意义的，只会增加交换次数，所以0要向左移动的位置一定是它左边1的个数
在遍历过程中，我们统计1的个数sum，每次遇到0答案就加上sum
```

**代码：**

```cpp
class Solution {
public:
    long long minimumSteps(string s) {
        long long ans = 0;
        int sum = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '1') {
                sum++;
            } else {
                ans += sum;
            }
        }
        return ans;
    }
};
```

**思路（从右向左）：**

```cpp
我们从右向左遍历，通过双指针标记遇到的0（j）和1（i）的位置。
当遇到从右向左第一个0，就从这里开始找左边第一个1，进行交换，答案增加j - i
直到i < 0 就说明交换完成了
class Solution {
public:
    long long minimumSteps(string s) {
        long long ans = 0;
        int n = s.size();
        int i = n - 1, j = n - 1;
        while (i >= 0) {
            while (j >= 0 && s[j] == '1') {
                j--;
            }
            if (j < 0) {
                return ans;
            }
            i = j;
            while (i >= 0 && s[i] == '0') {
                i--;
            }
            if (i < 0) {
                return ans;
            }
            ans += (j - i);
            s[j] = '1';
            s[i] = '0';
        }
        return ans;
    }
};
```

