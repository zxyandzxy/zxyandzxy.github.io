---
layout: post
title: "使二进制数组全部等于1的最少操作次数I"
date: 2024-10-18
tags: [leetcode]
comments: true
author: zxy
---

**题目：**

给你一个二进制数组 `nums` 。你可以对数组执行以下操作 **任意** 次（也可以 0 次）：

- 选择数组中 **任意连续** 3 个元素，并将它们 **全部反转** 。

**反转** 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。请你返回将 `nums` 中所有元素变为 1 的 **最少** 操作次数。如果无法全部变成 1 ，返回 -1 。

**示例 1：**

**输入：**nums = [0,1,1,1,0,0]

**输出：**3

**解释：**
我们可以执行以下操作：

- 选择下标为 0 ，1 和 2 的元素并反转，得到 `nums = [**1**,**0**,**0**,1,0,0]` 。
- 选择下标为 1 ，2 和 3 的元素并反转，得到 `nums = [1,**1**,**1**,**0**,0,0]` 。
- 选择下标为 3 ，4 和 5 的元素并反转，得到 `nums = [1,1,1,**1**,**1**,**1**]` 。

**示例 2：**

**输入：**nums = [0,1,1,1]

**输出：**-1

**解释：**
无法将所有元素都变为 1 。

**提示：**

- `3 <= nums.length <= 105`
- `0 <= nums[i] <= 1`

**思路：**

```
讨论是否需要对 i=0 执行操作：
	如果 nums[0] = 1，不需要操作，问题变成剩下 n−1 个数的子问题。
	如果 nums[0] = 0，一定要操作，问题变成剩下 n−1 个数的子问题。
接下来，讨论是否需要对 i = 1 执行操作，处理方式同上。
依此类推，一直到 i = n − 3 处理完后，还剩下 nums[n−2] 和 nums[n−1]，这两个数必须都等于 1，否则无法达成题目要求。

正确性
问：为什么这样做是对的？
答：
	先操作 i 再操作 j（i != j），和先操作 j 再操作 i 的结果是一样的，所以操作顺序不影响答案。既然操作顺序无影响，我们可以从左到右操作。或者说，假设某种操作顺序是最优的，那么总是可以把这个操作顺序重排成从左到右操作。
	对于同一个 i，操作两次等于没有操作，所以同一个 i 至多操作一次。注：操作 i 指的是反转 i, i+1, i+2 这三个位置。
	结合上述两点，既然同一个 i 至多操作一次，那么从左到右操作的过程中，遇到 1 一定不能操作，遇到 0 一定要操作，所以从左到右的操作方式有且仅有一种。
 既然操作方式是唯一的，我们只需模拟这个过程。

问：题目要求的「最少」体现在哪里？
答：对同一个 i 至多操作一次，就可以做到最少的操作次数。
```

**代码：**

```cpp
class Solution {
public:
    int minOperations(vector<int>& nums) {
        // 如果 nums[0] = 0，唯一让它变成 1 的方法是 翻转前3个字符
        // 基于贪心思路，我们希望只翻转一次，就能变成 1，所以第一个字符需要翻转，便只能翻转1次
        int ans = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 1) continue;
            if (i + 1 >= nums.size() || i + 2 >= nums.size()) return -1;
            ans++;
            for (int j = 0; j < 3; j++) {
                if (nums[i + j]) nums[i + j] = 0;
                else nums[i + j] = 1;
            }
        }
        return ans;
    }
};
```



