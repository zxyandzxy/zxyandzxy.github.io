---
layout: post
title: "找出最具竞争力的子序列"
date: 2024-5-24
tags: [leetcode]
comments: true
author: zxy
---

**题目：**

给你一个整数数组 `nums` 和一个正整数 `k` ，返回长度为 `k` 且最具 **竞争力** 的 `nums` 子序列。

数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。

在子序列 `a` 和子序列 `b` 第一个不相同的位置上，如果 `a` 中的数字小于 `b` 中对应的数字，那么我们称子序列 `a` 比子序列 `b`（相同长度下）更具 **竞争力** 。 例如，`[1,3,4]` 比 `[1,3,5]` 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， `4` 小于 `5` 。

**示例 1：**

```
输入：nums = [3,5,2,6], k = 2
输出：[2,6]
解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。
```

**示例 2：**

```
输入：nums = [2,4,3,3,5,4,9,6], k = 4
输出：[2,3,3,4]
```

**提示：**

- `1 <= nums.length <= 105`
- `0 <= nums[i] <= 109`
- `1 <= k <= nums.length`

**思路：**

```cpp
题意：返回 nums 的长度恰好为 k 的字典序最小子序列。

由于要返回的是 nums 的一个子序列，我们尝试在遍历 nums 的过程中，去生成字典序最小的子序列。
以示例 2 为例，nums[2,4,3,3,5,4,9,6], k=4。

	nums[0]=2，目前生成的子序列为 [2]。
	nums[1]=4，由于 4>2，不能把子序列中的 2 替换掉，因为这会让字典序变大。由于目标子序列长度为 k=4，所以直接把 4 加到子序列的末尾，目前生成的子序列为 [2,4]。
	nums[2]=3，由于 3<4，把子序列末尾的 4 去掉，添加 3，会让字典序变小。注意，不能继续把 2 也去掉，这会让字典序变大。目前生成的子序列为 [2,3]。
	nums[3]=3，无法让字典序变小，且当前子序列长度不足 k=4，所以直接把 3 加到子序列的末尾，目前生成的子序列为 [2,3,3]。
	nums[4]=5，无法让字典序变小，且当前子序列长度不足 k=4，所以直接把 5 加到子序列的末尾，目前生成的子序列为 [2,3,3,5]。
	nums[5]=4，由于 4<5，把子序列末尾的 5 去掉，添加 4，会让字典序变小。注意，不能继续把 3 也去掉，这会让字典序变大。目前生成的子序列为 [2,3,3,4]。注意：假如 k=7，这里不能把子序列末尾的 5 去掉，因为一旦去掉，即使把后面的所有元素都加到子序列中（得到 [2,3,3,4,9,6]），长度也无法达到 7，不符合题目要求。
	nums[6]=9，无法让字典序变小，且当前子序列长度已经等于 k=4，所以什么也不做，目前生成的子序列为 [2,3,3,4]。
	nums[7]=6，无法让字典序变小，且当前子序列长度已经等于 k=4，所以什么也不做，目前生成的子序列为 [2,3,3,4]。
按照上面的流程，为了维护生成的子序列，我们需要一个后进先出的数据结构：栈。当然，用列表/数组表示栈也可以。

算法如下：
	创建一个空栈。
	从左到右遍历 nums。
	设 x=nums[i]。如果栈不为空，且 x 小于栈顶，且栈的大小加上剩余元素个数（n−i）大于 k，则可以弹出栈顶。不断循环直到不满足这三个条件之一。
	如果栈的大小小于 k，把 x 入栈。
	遍历结束，栈（从底到顶的顺序）就是答案。
```

**代码：**

```cpp
class Solution {
public:
    vector<int> mostCompetitive(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> st;
        for (int i = 0; i < n; i++) {
            int x = nums[i];
            while (!st.empty() && x < st.back() && st.size() + n - i > k) {
                st.pop_back();
            }
            if (st.size() < k) st.push_back(x);
        }
        return st;
    }
};
```

