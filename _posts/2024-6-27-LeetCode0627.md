---
layout: post
title: "执行子串操作后的字典序最小字符串"
date: 2024-6-27
tags: [leetcode]
comments: true
author: zxy
---

**题目：**

给你一个仅由小写英文字母组成的字符串 `s` 。在一步操作中，你可以完成以下行为：

- 选择 `s` 的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，'b' 用 'a' 替换，'a' 用 'z' 替换。

返回执行上述操作 **恰好一次** 后可以获得的 **字典序最小** 的字符串。

**示例 1：**

```
输入：s = "cbabc"
输出："baabc"
解释：我们选择从下标 0 开始、到下标 1 结束的子字符串执行操作。 
可以证明最终得到的字符串是字典序最小的。
```

**示例 2：**

```
输入：s = "acbbc"
输出："abaab"
解释：我们选择从下标 1 开始、到下标 4 结束的子字符串执行操作。
可以证明最终得到的字符串是字典序最小的。
```

**示例 3：**

```
输入：s = "leetcode"
输出："kddsbncd"
解释：我们选择整个字符串执行操作。
可以证明最终得到的字符串是字典序最小的。
```

**提示：**

- `1 <= s.length <= 3 * 105`
- `s` 仅由小写英文字母组成

**思路：**

```
贪心算法：
	我们的目标是让字典序最小，由于我们的操作是让字母往前走1位，那么能让字典序变大的就只有字母a。
	基于此，我们的贪心思路是：从左到右，找到第一个非a的索引start,从start开始找到第一个为a的索引end,[start, end)就是我们要进行操作的子字符串
	在此过程中，注意进行边界条件的判断
```

**代码：**

```cpp
class Solution {
public:
    string smallestString(string s) {
        // 从左到右，如果是a就不换，否则就一直去找直到a / 结尾
        int n = s.size();
        int idx = 0;
        while (idx < n && s[idx] == 'a') {
            idx++;
        }
        if (idx == n) {
            s[idx - 1] = 'z';
            return s;
        }
        int j = idx;
        while (j < n && s[j] != 'a') {
            j++;
        }
        if (j == n) {
            // 从idx开始，之后到结尾
            for (int i = idx; i < n; i++) {
                s[i]--;
            }
        }else {
            // 从idx 到 j - 1
            for (int i = idx; i < j; i++) {
                s[i]--;
            }
        }
        return s;
    }
};
```

